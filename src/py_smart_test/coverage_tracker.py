"""Coverage-based dependency tracking for py_smart_test.

This module provides runtime dependency mapping using coverage data to
automatically link code changes to affected tests with higher precision
than static AST analysis alone.
"""

import json
import logging
from pathlib import Path
from typing import Dict, List, Set

from . import _paths

logger = logging.getLogger(__name__)

# Coverage data file location
COVERAGE_DATA_FILE = _paths.PY_SMART_TEST_DIR / "coverage_mapping.json"


def load_coverage_mapping() -> Dict[str, List[str]]:
    """Load the coverage mapping from disk.

    Returns a dict mapping source files to the tests that execute them.
    Format: {"src/module.py": ["tests/test_module.py::test_func", ...], ...}
    """
    if not COVERAGE_DATA_FILE.exists():
        logger.debug("No coverage mapping found.")
        return {}

    try:
        with open(COVERAGE_DATA_FILE, "r") as f:
            return json.load(f)
    except (json.JSONDecodeError, IOError) as e:
        logger.warning(f"Failed to load coverage mapping: {e}")
        return {}


def save_coverage_mapping(mapping: Dict[str, List[str]]) -> None:
    """Save the coverage mapping to disk.

    Args:
        mapping: Dict mapping source files to tests that execute them.
    """
    try:
        COVERAGE_DATA_FILE.parent.mkdir(parents=True, exist_ok=True)
        with open(COVERAGE_DATA_FILE, "w") as f:
            json.dump(mapping, f, indent=2)
        logger.debug(f"Saved coverage mapping to {COVERAGE_DATA_FILE}")
    except IOError as e:
        logger.error(f"Failed to save coverage mapping: {e}")


def merge_coverage_mapping(
    existing: Dict[str, List[str]], new_data: Dict[str, List[str]]
) -> Dict[str, List[str]]:
    """Merge new coverage data with existing mapping.

    Args:
        existing: Existing coverage mapping
        new_data: New coverage data to merge

    Returns:
        Merged mapping with deduplicated test lists
    """
    merged = existing.copy()

    for source_file, tests in new_data.items():
        if source_file in merged:
            # Merge and deduplicate
            merged[source_file] = sorted(set(merged[source_file]) | set(tests))
        else:
            merged[source_file] = sorted(tests)

    return merged


def get_tests_for_files(
    changed_files: List[Path], coverage_mapping: Dict[str, List[str]]
) -> Set[str]:
    """Get tests that cover the changed files based on coverage data.

    Args:
        changed_files: List of changed source files
        coverage_mapping: Coverage mapping data

    Returns:
        Set of test node IDs that cover the changed files
    """
    affected_tests = set()

    for file_path in changed_files:
        # Normalize path to match coverage mapping keys
        rel_path = str(file_path).replace("\\", "/")

        # Try both with and without leading ./
        for key in [rel_path, f"./{rel_path}", file_path.name]:
            if key in coverage_mapping:
                affected_tests.update(coverage_mapping[key])
                logger.debug(f"Found {len(coverage_mapping[key])} tests for {rel_path}")
                break

    return affected_tests


def update_coverage_from_pytest_run(coverage_file: Path) -> None:
    """Update coverage mapping from a pytest-cov .coverage file.

    This function reads a coverage.py data file and updates the mapping of
    source files that were executed during the test run.

    Note:
        Current implementation only identifies covered files; test-specific
        attribution requires pytest-cov plugin integration and will be added
        in a future update.

    Args:
        coverage_file: Path to the .coverage file generated by pytest-cov
    """
    try:
        # Import coverage library (optional dependency)
        import coverage
    except ImportError:
        from .utils import get_optional_dependency_message

        logger.warning(get_optional_dependency_message("coverage"))
        return

    try:
        cov = coverage.Coverage(data_file=str(coverage_file))
        cov.load()

        # Get coverage data
        data = cov.get_data()

        # Build mapping of source files to tests
        new_mapping: Dict[str, Set[str]] = {}

        # Note: coverage.py tracks which tests execute which lines,
        # but extracting test-to-file mappings requires plugin integration
        # For now, we'll use a simplified approach

        for source_file in data.measured_files():
            # Skip non-Python files and test files
            if not source_file.endswith(".py"):
                continue

            # Check if 'tests' is in the path (cross-platform)
            try:
                source_path = Path(source_file)
                if "tests" in source_path.parts:
                    continue
            except Exception:
                continue

            # Normalize path relative to repo root
            try:
                rel_path = Path(source_file).relative_to(_paths.REPO_ROOT)
                rel_path_str = rel_path.as_posix()

                # For now, mark as "covered" without specific test attribution
                # Full implementation requires pytest-cov plugin integration
                if rel_path_str not in new_mapping:
                    new_mapping[rel_path_str] = set()

            except ValueError:
                # File outside repo root, skip
                continue

        # Convert sets to lists and merge with existing mapping
        new_mapping_lists = {k: sorted(v) for k, v in new_mapping.items()}
        existing = load_coverage_mapping()
        merged = merge_coverage_mapping(existing, new_mapping_lists)
        save_coverage_mapping(merged)

        logger.info(f"Updated coverage mapping with data from {coverage_file}")

    except Exception as e:
        logger.error(f"Failed to update coverage mapping: {e}")


def clear_coverage_mapping() -> None:
    """Clear the coverage mapping data."""
    if COVERAGE_DATA_FILE.exists():
        COVERAGE_DATA_FILE.unlink()
        logger.info("Cleared coverage mapping data")
